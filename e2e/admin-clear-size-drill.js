import { check, sleep } from 'k6';
import exec from 'k6/execution';
import { openKv } from 'k6/x/kv';

// =============================================================================
// REAL-WORLD SCENARIO: ADMIN “NUKE & RESEED” MAINTENANCE WINDOW
// =============================================================================
//
// Operators occasionally wipe entire keyspaces (kv.clear()) while other workers
// continue to write scratch data. This script keeps the writes flowing while a
// single coordinator issues periodic clear()+size() checks to ensure promises
// resolve cleanly under concurrent churn.
//
// REAL-WORLD PROBLEMS UNCOVERED:
// - clear() and size() promises resolving on goroutines other than the event loop.
// - Inconsistent size readings when clear() collides with active writers.
// - Residual keys that should have been deleted during maintenance windows.
//
// ATOMIC OPERATIONS TESTED:
// - set(): background writers.
// - clear(): coordinator nukes the store.
// - size(): coordinator validates that clear finished.

// Selected backend (memory or disk) used for the maintenance drill.
const SELECTED_BACKEND_NAME = __ENV.KV_BACKEND || 'memory';
// Enables in-memory key tracking when the backend is memory.
const TRACK_KEYS_OVERRIDE =
  typeof __ENV.KV_TRACK_KEYS === 'string' ? __ENV.KV_TRACK_KEYS.toLowerCase() : '';
const ENABLE_TRACK_KEYS_FOR_MEMORY_BACKEND =
  TRACK_KEYS_OVERRIDE === '' ? true : TRACK_KEYS_OVERRIDE === 'true';

// Prefix applied to scratch keys generated by writers.
const SCRATCH_PREFIX = __ENV.SCRATCH_PREFIX || 'scratch:';
// Number of scratch keys each writer stores per iteration.
const BATCH_KEYS = parseInt(__ENV.BATCH_KEYS || '80', 10);
// Interval (iterations) between maintenance cycles.
const CLEAR_INTERVAL = parseInt(__ENV.CLEAR_INTERVAL || '7', 10);
// Pause (seconds) enforced for non-coordinator VUs during maintenance.
const MAINTENANCE_PAUSE_SECONDS = parseFloat(__ENV.MAINTENANCE_PAUSE_SECONDS || '0.05');
// Base duration (seconds) each iteration sleeps after processing.
const BASE_IDLE_SLEEP_SECONDS = parseFloat(__ENV.BASE_IDLE_SLEEP_SECONDS || '0.02');
// Random jitter (seconds) added to the base idle sleep.
const IDLE_SLEEP_JITTER_SECONDS = parseFloat(
  __ENV.IDLE_SLEEP_JITTER_SECONDS || '0.01'
);
// Default number of VUs used by the scenario.
const DEFAULT_VUS = parseInt(__ENV.VUS || '40', 10);
// Default iteration count used by the scenario.
const DEFAULT_ITERATIONS = parseInt(__ENV.ITERATIONS || '400', 10);

// kv is the shared store client used throughout the scenario.
const kv = openKv(
  SELECTED_BACKEND_NAME === 'disk'
    ? { backend: 'disk', trackKeys: ENABLE_TRACK_KEYS_FOR_MEMORY_BACKEND }
    : { backend: 'memory', trackKeys: ENABLE_TRACK_KEYS_FOR_MEMORY_BACKEND }
);

// options configures the load profile and pass/fail thresholds.
export const options = {
  vus: DEFAULT_VUS,
  iterations: DEFAULT_ITERATIONS,
  thresholds: {
    'checks{clear:store-empty}': ['rate>0.99']
  }
};

// setup resets the store before the rehearsal begins.
export async function setup() {
  await kv.clear();
}

// teardown shuts down disk-backed stores so subsequent runs can start cleanly.
export async function teardown() {
  if (SELECTED_BACKEND_NAME === 'disk') {
    kv.close();
  }
}

// adminClearSizeDrill writes scratch keys and occasionally executes coordinated
// clear()+size() probes to verify promise resolution under heavy churn.
export default async function adminClearSizeDrill() {
  const iteration = exec.scenario.iterationInTest;
  const coordinator = exec.vu.idInInstance === 1;
  const isMaintenanceTick = iteration % CLEAR_INTERVAL === 0;

  if (isMaintenanceTick) {
    if (coordinator) {
      await kv.clear();
      const sizeAfter = await kv.size();

      check(true, {
        'clear:store-empty': () => sizeAfter === 0
      });
    } else {
      // Non-coordinator VUs pause to emulate drained traffic during maintenance.
      sleep(MAINTENANCE_PAUSE_SECONDS);
    }

    // Keep the iteration alive long enough for Sobek to process pending callbacks.
    sleep(BASE_IDLE_SLEEP_SECONDS + Math.random() * IDLE_SLEEP_JITTER_SECONDS);
    return;
  }

  const scratchKeys = Array.from({ length: BATCH_KEYS }, (_, idx) => {
    return `${SCRATCH_PREFIX}${exec.vu.idInInstance}:${iteration}:${idx}`;
  });

  await Promise.all(
    scratchKeys.map((key, idx) =>
      kv.set(key, {
        key,
        payload: `blob-${idx}`,
        createdAt: Date.now()
      })
    )
  );

  // Simulate work long enough to keep the scenario under load.
  sleep(BASE_IDLE_SLEEP_SECONDS + Math.random() * IDLE_SLEEP_JITTER_SECONDS);
}

